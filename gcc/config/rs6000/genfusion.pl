#!/usr/bin/perl
# Generate fusion.md
#
# Copyright (C) 2020-2023 Free Software Foundation, Inc.
#
# This file is part of GCC.
#
# GCC is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# GCC is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GCC; see the file COPYING3.  If not see
# <http://www.gnu.org/licenses/>.

use warnings;
use strict;

sub gen_copyright_and_top_comments
{
  print << "EOF";
;; Generated automatically by genfusion.pl

;; Copyright (C) 2020-2023 Free Software Foundation, Inc.
;;
;; This file is part of GCC.
;;
;; GCC is free software; you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free
;; Software Foundation; either version 3, or (at your option) any later
;; version.
;;
;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
;; WARRANTY; without even the implied warranty of MERCHANTABILITY or
;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
;; for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

EOF
}

# Map any mode of DI/SI/HI/QI to single char d/w/h/b,
# die if the given mode in arg 0 isn't expected.
sub mode_to_ldst_char
{
  my $mode = $_[0];
  die "Unexpected mode: $mode" unless $mode =~ /[QHSD]I/;
  my %map = (DI => 'd', SI => 'w', HI => 'h', QI => 'b');
  return $map{$mode};
}

# Emit define_insn_and_split for load-cmpi fusion type based
# on the below given arguments:
#   arg 0: mode of load.
#   arg 1: mode of result.
#   arg 2: mode of comparison.
#   arg 3: extension type.
sub ld_cmpi_p10_emit_define
{
  my $lmode = $_[0];
  my $result = $_[1];
  my $ccmode = $_[2];
  my $extend = $_[3];

  # For clobber, we need a SI/DI reg in case we
  # split because we have to sign/zero extend.
  my $clobbermode = ($lmode eq 'HI' || $lmode eq 'QI') ? 'GPR' : $lmode;

  my $np = 'NON_PREFIXED_D';
  my $mempred = 'non_update_memory_operand';

  # ld and lwa are both DS-FORM.
  if ( $lmode eq 'DI'
      || ($lmode eq 'SI' && $ccmode eq 'CC') ) {
    $np = 'NON_PREFIXED_DS';
    $mempred = 'ds_form_mem_operand';
  }

  my $cmpl = '';
  my $echr = 'a';
  my $constpred = 'const_m1_to_1_operand';

  # Logical comparison has 'l', zero extended load has 'z'.
  if ($ccmode eq 'CCUNS') {
    $cmpl = 'l';
    $echr = 'z';
    $constpred = 'const_0_to_1_operand';
  }

  # DI load doesn't have suffix for zero or sign.
  $echr = '' if $lmode eq 'DI';

  my $ldst = mode_to_ldst_char ($lmode);

  # define_insn_and_split comments.
  print ";; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n";
  print ";; load mode is $lmode result mode is $result compare mode is $ccmode extend is $extend\n";

  # main set pattern.
  print "(define_insn_and_split \"*l${ldst}${echr}_cmp${cmpl}di_cr0_${lmode}_${result}_${ccmode}_${extend}\"\n";
  print "  [(set (match_operand:${ccmode} 2 \"cc_reg_operand\" \"=x\")\n";
  print "        (compare:${ccmode} (match_operand:${lmode} 1 \"${mempred}\" \"m\")\n";
  print "   " if ($ccmode eq 'CCUNS');
  print "                    (match_operand:${lmode} 3 \"${constpred}\" \"n\")))\n";

  # clobber or another set pattern.
  if ($result eq 'clobber') {
    print "   (clobber (match_scratch:${clobbermode} 0 \"=r\"))]\n";
  } elsif ($result eq $lmode) {
    print "   (set (match_operand:${result} 0 \"gpc_reg_operand\" \"=r\") (match_dup 1))]\n";
  } else {
    print "   (set (match_operand:${result} 0 \"gpc_reg_operand\" \"=r\") (${extend}_extend:${result} (match_dup 1)))]\n";
  }

  # insn condition and output template.
  print "  \"(TARGET_P10_FUSION)\"\n";
  print "  \"l${ldst}${echr}%X1 %0,%1\\;cmp${cmpl}di %2,%0,%3\"\n";

  # split condition.
  print "  \"&& reload_completed\n";
  print "   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n";
  print "       || !address_is_non_pfx_d_or_x (XEXP (operands[1], 0),\n";
  print "                                      ${lmode}mode, ${np}))\"\n";

  # new insn patterns.
  if ($extend eq 'none') {
    print "  [(set (match_dup 0) (match_dup 1))\n";
  } else {
    my $resultmode = ( $result eq 'clobber' ) ? $clobbermode : $result;
    print "  [(set (match_dup 0) (${extend}_extend:${resultmode} (match_dup 1)))\n";
  }
  print "   (set (match_dup 2)\n";
  print "        (compare:${ccmode} (match_dup 0) (match_dup 3)))]\n";
  print "  \"\"\n";

  # insn attributes.
  print "  [(set_attr \"type\" \"fused_load_cmpi\")\n";
  print "   (set_attr \"cost\" \"8\")\n";
  print "   (set_attr \"length\" \"8\")])\n";
  print "\n";
}

# Main subroutine to generate load-cmpi fusion type.
sub gen_ld_cmpi_p10
{
  # For load mode is DI, there is no EXTDI, the result of
  # DI doesn't need extension.
  ld_cmpi_p10_emit_define ('DI', 'clobber', 'CC', 'none');
  ld_cmpi_p10_emit_define ('DI', 'clobber', 'CCUNS', 'none');
  ld_cmpi_p10_emit_define ('DI', 'DI', 'CC', 'none');
  ld_cmpi_p10_emit_define ('DI', 'DI', 'CCUNS', 'none');

  # For load mode is SI, only EXTSI need extension.
  ld_cmpi_p10_emit_define ('SI', 'clobber', 'CC', 'none');
  ld_cmpi_p10_emit_define ('SI', 'clobber', 'CCUNS', 'none');
  ld_cmpi_p10_emit_define ('SI', 'SI', 'CC', 'none');
  ld_cmpi_p10_emit_define ('SI', 'SI', 'CCUNS', 'none');
  ld_cmpi_p10_emit_define ('SI', 'EXTSI', 'CC', 'sign');
  ld_cmpi_p10_emit_define ('SI', 'EXTSI', 'CCUNS', 'zero');

  # For load mode is HI, we can't produce HI result directly.
  # We always need extension if result is wider than load
  # mode.
  ld_cmpi_p10_emit_define ('HI', 'clobber', 'CC', 'sign');
  ld_cmpi_p10_emit_define ('HI', 'clobber', 'CCUNS', 'zero');
  ld_cmpi_p10_emit_define ('HI', 'EXTHI', 'CC', 'sign');
  ld_cmpi_p10_emit_define ('HI', 'EXTHI', 'CCUNS', 'zero');

  # For load mode is QI, we can't produce QI result directly,
  # also ignore CC here.  We always need extension if result
  # is wider than load mode.
  ld_cmpi_p10_emit_define ('QI', 'clobber', 'CCUNS', 'zero');
  # Don't allow EXTQI because that would allow HI result
  # which we can't do.
  ld_cmpi_p10_emit_define ('QI', 'GPR', 'CCUNS', 'zero');
}

# Emit define_insn_and_split for logical/addsubf fusion type
# based the below given arguments:
#   arg 0: string for fusion type in comments, can only be
#          "logical-logical", "logical-add" or "add-logical".
#   arg 1: "scalar" or "vector".
#   arg 2: outer operator.
#   arg 3: inner operator.
#   arg 4: machine mode.
#   arg 5: predicate.
#   arg 6: constraint.
#   arg 7: expression pattern made by logical_addsubf_make_exp.
#   arg 8: fusion type for insn type attribute.
sub logical_addsubf_emit_define
{
  my ($ftype, $kind, $outer_op, $inner_op, $mode, $pred, $cstr,
      $exp, $fuse_type) = @_;

  # Make some adjustments for subf and rsubf.
  my $outer_name = $outer_op;
  $outer_op = 'subf' if $outer_op eq 'rsubf';

  my $ops32 = '%3,%2';
  my $ops42 = '%4,%2';
  if ( $outer_name eq 'subf' ) {
    $ops32 = '%2,%3';
    $ops42 = '%2,%4';
  }

  print << "EOF";

;; $ftype fusion pattern generated by gen_logical_addsubf
;; $kind $inner_op -> $outer_name
(define_insn "*fuse_${inner_op}_${outer_name}"
  [(set (match_operand:${mode} 3 "${pred}" "=&0,&1,&${cstr},${cstr}")
        ${exp})
   (clobber (match_scratch:${mode} 4 "=X,X,X,&${cstr}"))]
  "(TARGET_P10_FUSION)"
  "@
   ${inner_op} %3,%1,%0\\;${outer_op} %3,${ops32}
   ${inner_op} %3,%1,%0\\;${outer_op} %3,${ops32}
   ${inner_op} %3,%1,%0\\;${outer_op} %3,${ops32}
   ${inner_op} %4,%1,%0\\;${outer_op} %3,${ops42}"
  [(set_attr "type" "$fuse_type")
   (set_attr "cost" "6")
   (set_attr "length" "8")])
EOF
}

# For the given operator in arg 0, return an array holding the
# information on complementing, inverting, commuting and rtl
# operator name, die if the given operator isn't expected.
sub logical_addsub_get_op_info
{
  my $op = $_[0];

  # Checking the given OP is valid
  my @valid_ops = ( 'and', 'andc', 'eqv', 'nand', 'nor', 'or', 'orc', 'xor',
                    'add', 'subf', 'rsubf' );
  die "Unexpected op:$op" unless grep (/^$op$/, @valid_ops);

  my %complement = ( 'and'=> 0, 'andc'=> 1, 'eqv'=> 0, 'nand'=> 3,
                     'nor'=> 3, 'or'=> 0, 'orc'=> 1, 'xor'=> 0,
                     'add'=> 0, 'subf'=> 0 );
  my %invert     = ( 'and'=> 0, 'andc'=> 0, 'eqv'=> 1, 'nand'=> 0,
                     'nor'=> 0, 'or'=> 0, 'orc'=> 0, 'xor'=> 0,
                     'add'=> 0, 'subf'=> 0 );
  my %commute2   = ( 'and'=> 1, 'andc'=> 0, 'eqv'=> 1, 'nand'=> 0,
                     'nor'=> 0, 'or'=> 1, 'orc'=> 0, 'xor'=> 1 );
  my %rtl_ops    = ( 'and'=>'and', 'andc'=>'and', 'eqv'=>'xor', 'nand'=>'ior',
                     'nor'=>'and', 'or'=>'ior', 'orc'=>'ior', 'xor'=>'xor',
                     'add'=>'plus', 'subf'=>'minus' );

  return ($complement{$op}, $invert{$op}, $commute2{$op}, $rtl_ops{$op});
}

# For logical/addsubf fusion type, make up an expression based on
# the below given arguments:
#   arg 1: outer operator.
#   arg 2: inner operator.
#   arg 3: machine mode.
#   arg 4: predicate.
#   arg 5: constraint.
sub logical_addsubf_make_exp
{
  my ($outer_op, $inner_op, $mode, $pred, $cstr) = @_;

  my $outer_is_rsubf_p = 0;
  if ($outer_op eq 'rsubf') {
    $outer_op = 'subf';
    $outer_is_rsubf_p = 1;
  }

  my ($outer_comp, $outer_invert_p, $outer_comm_p,
      $outer_rtl_op) = logical_addsub_get_op_info ($outer_op);
  my ($inner_comp, $inner_invert_p, $inner_comm_p,
      $inner_rtl_op) = logical_addsub_get_op_info ($inner_op);

  # If both ops commute then we can specify % on operand 1
  # so the pattern will let operands 1 and 2 interchange.
  my $bc = '';
  $bc = '%' if ($inner_op eq $outer_op) && $inner_comm_p;

  my $cstr4 = "${cstr},${cstr},${cstr},${cstr}";

  # Make up arg0 (inner).
  my $arg0 = "(match_operand:${mode} 0 \"${pred}\" \"${cstr4}\")";
  $arg0 = "(not:${mode} $arg0)" if ($inner_comp & 1) == 1;

  # Make up arg1 (inner).
  my $arg1 = "(match_operand:${mode} 1 \"${pred}\" \"${bc}${cstr4}\")";
  $arg1 = "(not:${mode} $arg1)" if ($inner_comp & 2) == 2;

  # Make up inner_exp.
  my $inner_exp = "(${inner_rtl_op}:${mode} ${arg0}
                          ${arg1})";

  # Invert inner_exp if needed.
  $inner_exp = "(not:${mode} $inner_exp)" if ( $inner_invert_p );

  # Make up outer arg2.
  my $arg2 = "(match_operand:${mode} 2 \"${pred}\" \"${cstr4}\")";
  $arg2 = "(not:${mode} $arg2)" if ($outer_comp & 1) == 1;

  # Complement inner_exp if needed.
  $inner_exp = "(not:${mode} $inner_exp)" if ($outer_comp & 2) == 2;

  my $outer_exp;
  # Make up outer_exp and special casing rsubf.
  if ($outer_is_rsubf_p) {
    $outer_exp = "(${outer_rtl_op}:${mode} ${arg2}
                 ${inner_exp})";
  } else {
    $outer_exp = "(${outer_rtl_op}:${mode} ${inner_exp}
                 ${arg2})";
  }

  # Invert outer_exp if needed.
  $outer_exp = "(not:${mode} $outer_exp)" if $outer_invert_p;

  return $outer_exp;
}

# Generate logical/addsubf fusion type for scalar.
sub gen_logical_addsubf_scalar
{
  my $mode = 'GPR';
  my $pred = 'gpc_reg_operand';
  my $fuse_type = 'fused_arith_logical';
  my $constraint = 'r';

  my @logicals = ( 'and', 'andc', 'eqv', 'nand', 'nor', 'or', 'orc', 'xor' );

  # logical-logical
  foreach my $outer_op ( @logicals ) {
    foreach my $inner_op ( @logicals ) {
      my $exp = logical_addsubf_make_exp ($outer_op, $inner_op, $mode,
                                          $pred, $constraint);
      logical_addsubf_emit_define ('logical-logical', 'scalar', $outer_op,
                                   $inner_op, $mode, $pred, $constraint,
                                   $exp, $fuse_type);
    }
  }

  # logical ops which can fuse with add/subf/rsubf
  my @logicals2 = ( 'and', 'nand', 'nor', 'or' );
  my @add_subf = ( 'add', 'subf' );

  # add-logical
  foreach my $outer_op ( @logicals2 ) {
    foreach my $inner_op ( @add_subf ) {
      my $exp = logical_addsubf_make_exp ($outer_op, $inner_op, $mode,
                                          $pred, $constraint);
      logical_addsubf_emit_define ('add-logical', 'scalar', $outer_op,
                                   $inner_op, $mode, $pred, $constraint,
                                   $exp, $fuse_type);
    }
  }

  my @add_subf_rsubf = ( 'add', 'subf', 'rsubf' );

  # logical-add
  foreach my $outer_op ( @add_subf_rsubf ) {
    foreach my $inner_op ( @logicals2 ) {
      my $exp = logical_addsubf_make_exp ($outer_op, $inner_op, $mode,
                                          $pred, $constraint);
      logical_addsubf_emit_define ('logical-add', 'scalar', $outer_op,
                                   $inner_op, $mode, $pred, $constraint,
                                   $exp, $fuse_type);
    }
  }
}

# Generate logical/addsubf fusion type for vector.
sub gen_logical_addsubf_vector
{
  my $mode = "VM";
  my $pred = "altivec_register_operand";
  my $fuse_type = "fused_vector";
  my $constraint = "v";

  my @logicals = ( 'and', 'andc', 'eqv', 'nand', 'nor', 'or', 'orc', 'xor' );

  # logical-logical
  foreach my $outer_op ( @logicals ) {
    foreach my $inner_op ( @logicals ) {
      my $exp = logical_addsubf_make_exp ($outer_op, $inner_op, $mode,
                                          $pred, $constraint);
      logical_addsubf_emit_define ('logical-logical', 'vector', "v${outer_op}",
                                   "v${inner_op}", $mode, $pred, $constraint,
                                   $exp, $fuse_type);
    }
  }
}

# Main subroutine to generate logical/addsubf fusion type.
sub gen_logical_addsubf
{
  gen_logical_addsubf_scalar ();
  gen_logical_addsubf_vector ();
}

# Main subroutine to generate add-add fusion type.
sub gen_addadd
{
    my ($kind, $op, $type, $mode, $pred, $constraint);
    foreach $kind ('scalar','vector') {
      if ( $kind eq 'vector' ) {
	  $op = "vaddudm";
	  $type = "fused_vector";
	  $mode = "V2DI";
	  $pred = "altivec_register_operand";
	  $constraint = "v";
      } else {
	  $op = "add";
	  $type = "fused_arith_logical";
	  $mode = "GPR";
	  $pred = "gpc_reg_operand";
	  $constraint = "r";
      }
    my $c4 = "${constraint},${constraint},${constraint},${constraint}";
    print <<"EOF";

;; ${op}-${op} fusion pattern generated by gen_addadd
(define_insn "*fuse_${op}_${op}"
  [(set (match_operand:${mode} 3 "${pred}" "=&0,&1,&${constraint},${constraint}")
        (plus:${mode}
           (plus:${mode} (match_operand:${mode} 0 "${pred}" "${c4}")
                     (match_operand:${mode} 1 "${pred}" "%${c4}"))
           (match_operand:${mode} 2 "${pred}" "${c4}")))
   (clobber (match_scratch:${mode} 4 "=X,X,X,&${constraint}"))]
  "(TARGET_P10_FUSION)"
  "@
   ${op} %3,%1,%0\\;${op} %3,%3,%2
   ${op} %3,%1,%0\\;${op} %3,%3,%2
   ${op} %3,%1,%0\\;${op} %3,%3,%2
   ${op} %4,%1,%0\\;${op} %3,%4,%2"
  [(set_attr "type" "${type}")
   (set_attr "cost" "6")
   (set_attr "length" "8")])
EOF
  }
}

sub main {
  gen_copyright_and_top_comments ();
  gen_ld_cmpi_p10 ();
  gen_logical_addsubf ();
  gen_addadd ();
  return 0;
}

exit main ();

