# Test code for libdiagnostics.so
#
# FIXME:
#
# Test code for libdiagnostics.so
# We will compile each of jit.dg/test-*.c into an executable
# dynamically linked against libgccjit.so, and then run each
# such executable.
#
# These executables call into the libgccjit.so API to create
# code, compile it, and run it, verifying that the results
# are as expected.  See harness.h for shared code used by all
# such executables.
#
# The executables call into DejaGnu's unit testing C API to
# report PASS/FAIL results, which this script gathers back
# up into the Tcl world, reporting a summary of all results
# across all of the executables.

# Kludge alert:
# We need g++_init so that it can find the stdlib include path.
#
# g++_init (in lib/g++.exp) uses g++_maybe_build_wrapper,
# which normally comes from the definition of
# ${tool}_maybe_build_wrapper within lib/wrapper.exp.
#
# However, for us, ${tool} is "jit".
# Hence we load wrapper.exp with tool == "g++", so that
# g++_maybe_build_wrapper is defined.
set tool g++
load_lib wrapper.exp
set tool diagnostics

load_lib dg.exp
load_lib prune.exp
load_lib target-supports.exp
load_lib gcc-defs.exp
load_lib timeout.exp
load_lib target-libpath.exp
load_lib gcc.exp
load_lib g++.exp
load_lib dejagnu.exp
load_lib target-supports-dg.exp

# # Skip these tests for targets that don't support -ldiagnostics
# if { ![check_effective_target_ldiagnostics] } {
#     return
# }

# The default do-what keyword.
set dg-do-what-default compile

# Look for lines of the form:
#   definitely lost: 11,316 bytes in 235 blocks
#   indirectly lost: 352 bytes in 4 blocks
# Ideally these would report zero bytes lost (which is a PASS);
# for now, report non-zero leaks as XFAILs.
proc report_leak {kind name logfile line} {
    set match [regexp "$kind lost: .*" $line result]
    if $match {
	verbose "Saw \"$result\" within \"$line\"" 4
	# Extract bytes and blocks.
	# These can contain commas as well as numerals,
	# but we only care about whether we have zero.
	regexp "$kind lost: (.+) bytes in (.+) blocks" \
	    $result -> bytes blocks
	verbose "bytes: '$bytes'" 4
	verbose "blocks: '$blocks'" 4
	if { $bytes == 0 } {
	    pass "$name: $logfile: $result"
	} else {
	    xfail "$name: $logfile: $result"
	}
    }
}

proc parse_valgrind_logfile {name logfile} {
    verbose "parse_valgrind_logfile: $logfile" 2
    if [catch {set f [open $logfile]}] {
	fail "$name: unable to read $logfile"
	return
    }

    while { [gets $f line] >= 0 } {
	# Strip off the PID prefix e.g. ==7675==
	set line [regsub "==\[0-9\]*== " $line ""]
	verbose $line 2

	report_leak "definitely" $name $logfile $line
	report_leak "indirectly" $name $logfile $line
    }
    close $f
}

# Given WRES, the result from "wait", issue a PASS
# if the spawnee exited cleanly, or a FAIL for various kinds of
# unexpected exits.

proc verify_exit_status { executable wres } {
    lassign $wres pid spawnid os_error_flag value
    verbose "pid: $pid" 3
    verbose "spawnid: $spawnid" 3
    verbose "os_error_flag: $os_error_flag" 3
    verbose "value: $value" 3

    # Detect segfaults etc:
    if { [llength $wres] > 4 } {
	if { [lindex $wres 4] == "CHILDKILLED" } {
	    fail "$executable killed: $wres"
	    return
	}
    }
    if { $os_error_flag != 0 } {
	fail "$executable: OS error: $wres"
	return
    }
    if { $value != 0 } {
	fail "$executable: non-zero exit code: $wres"
	return
    }
    pass "$executable exited cleanly"
}

# This is host_execute from dejagnu.exp commit
#   126a089777158a7891ff975473939f08c0e31a1c
# with the following patch applied, and renaming to "fixed_host_execute".
# See the discussion at
#  http://lists.gnu.org/archive/html/dejagnu/2014-10/msg00000.html
#
#  --- /usr/share/dejagnu/dejagnu.exp.old  2014-10-08 13:38:57.274068541 -0400
#  +++ /usr/share/dejagnu/dejagnu.exp      2014-10-10 12:27:51.113813659 -0400
#  @@ -113,8 +113,6 @@ proc host_execute {args} {
#       set timetol 0
#       set arguments ""
#   
#  -    expect_before buffer_full { perror "Buffer full" }
#  -
#       if { [llength $args] == 0} {
#          set executable $args
#       } else {


# Execute the executable file, and anaylyse the output for the
# test state keywords.
#    Returns:
#	A "" (empty) string if everything worked, or an error message
#	if there was a problem.
#
proc fixed_host_execute {args} {
    global env
    global text
    global spawn_id

    verbose "fixed_host_execute: $args"

    set timeoutmsg "Timed out: Never got started, "
    set timeout 100
    set file all
    set timetol 0
    set arguments ""

    if { [llength $args] == 0} {
	set executable $args
    } else {
	set executable [lindex $args 0]
	set params [lindex $args 1]
    }

    verbose "The executable is $executable" 2
    if {![file exists ${executable}]} {
	perror "The executable, \"$executable\" is missing" 0
	return "No source file found"
    } elseif {![file executable ${executable}]} {
	perror "The executable, \"$executable\" is not usable" 0
	return "Bad executable found"
    }

    verbose "params: $params" 2

    # spawn the executable and look for the DejaGnu output messages from the
    # test case.
    # spawn -noecho -open [open "|./${executable}" "r"]

    # Run under valgrind if RUN_UNDER_VALGRIND is present in the environment.
    # Note that it's best to configure gcc with --enable-valgrind-annotations
    # when testing under valgrind.
    set run_under_valgrind [info exists env(RUN_UNDER_VALGRIND)]
    if $run_under_valgrind {
	set valgrind_logfile "${executable}.valgrind.txt"
	set valgrind_params {"valgrind"}
	lappend valgrind_params "--leak-check=full"
	lappend valgrind_params "--log-file=${valgrind_logfile}"
    } else {
	set valgrind_params {}
    }
    verbose "valgrind_params: $valgrind_params" 2

    set args ${valgrind_params}
    lappend args "./${executable}"
    set args [concat $args ${params}]
    verbose "args: $args" 2

    # We checked that the executable exists above, and can be executed, but
    # that does not cover other reasons that the launch could fail (e.g.
    # missing or malformed params); catch such cases here and report them.
    set err [catch "spawn -noecho $args" pid]
    set sub_proc_id $spawn_id
    if { $pid <= 0 || $err != 0 || $sub_proc_id < 0 } {
        warning "failed to spawn : $args : err = $err"
    }

    # Increase the buffer size, if needed to avoid spurious buffer-full
    # events; GCC uses 10000; chose a power of two here.
    set current_max_match [match_max -i $sub_proc_id]
    if { $current_max_match < 8192 } {
        match_max -i $sub_proc_id 8192
        set used [match_max -i $sub_proc_id]
    }

    # If we get a buffer-full error, that seems to be unrecoverable so try to
    # exit in a reasonable manner to avoid wedged processes.
    expect_after full_buffer {
        verbose -log "fixed_host_execute: $args FULL BUFFER"
        # FIXME: this all assumes that closing the connection will cause the
        # sub-process to terminate (but that is not going to be the case if,
        # for example, there is something started with -nohup somewhere).
        # We should explicitly kill it here.
        # Set the process to be a nowait exit.
        wait -nowait -i $sub_proc_id
        catch close
        perror "${executable} got full_buffer"
        return "${executable} got full_buffer"
    }

    set prefix "\[^\r\n\]*"
    # Work around a Darwin tcl or termios bug that sometimes inserts extra
    # CR characters into the cooked tty stream
    set endline "\r\n"
    if { [istarget *-*-darwin*] } {
        set endline "\r(\r)*\n"
    }
    
    # Note that the logic here assumes that we cannot (validly) get single
    # carriage return or line feed characters in the stream.  If those occur,
    # it will stop any further matching.  We arange for the matching to be
    # at the start of the buffer - so that if there is any spurious output
    # to be discarded, it must be done explicitly - not by matching part-way
    # through the buffer.
    expect {
	-re "^$prefix\[0-9\]\[0-9\]:..:..:${text}*$endline" {
	    regsub "\[\n\r\t\]*NOTE: $text\r\n" $expect_out(0,string) "" output
	    verbose "$output" 3
	    set timetol 0
	    exp_continue
	}
	-re "^\tNOTE: (\[^\r\n\]+)$endline" {
	    # discard notes.
	    verbose "Ignored note: $expect_out(1,string)" 2
	    set timetol 0
	    exp_continue
	}
	-re "^\tPASSED: (\[^\r\n\]+)$endline" {
	    pass "$expect_out(1,string)"
	    set timetol 0
	    exp_continue
	}
	-re "^\tFAILED: (\[^\r\n\]+)$endline" {
	    fail "$expect_out(1,string)"
	    set timetol 0
	    exp_continue
	}
	-re "^\tUNTESTED: (\[^\r\n\]+)$endline" {
	    untested "$expect_out(1,string)"
	    set timetol 0
	    exp_continue
	}
	-re "^\tUNRESOLVED: (\[^\r\n\]+)$endline" {
	    unresolved "$expect_out(1,string)"
	    set timetol 0
	    exp_continue
	}
	-re "^$prefix$endline" {
            # This matches and discards any other lines (including blank ones).
            if { [string length $expect_out(buffer)] <= 2 } {
                set output "blank line"
            } else {
	        set output [string range $expect_out(buffer) 0 end-2]
	    }
	    verbose -log "DISCARDED $expect_out(spawn_id) : $output"
	    exp_continue
	}
	eof {
	    # This seems to be the only way that we can reliably know that the
	    # output is finished since there are cases where further output
	    # follows the dejagnu test harness totals.
	    verbose "saw eof" 2
	}
	timeout {
	    if { $timetol <= 2 } {
	        verbose -log "Timed out with retry (timeout = $timeout)"
		incr timetol
		exp_continue
	    } else {
	        warning "Timed out executing testcase (timeout = $timeout)"
		catch close
		return "Timed out executing test case"
	    }
	}
    }

    # Use "wait" to pick up the sub-process exit state.  If the sub-process is
    # writing to a file (perhaps under valgrind) then that also needs to be
    # complete; only attempt this on a valid spawn.
    if { $sub_proc_id > 0 } {
        verbose "waiting for $sub_proc_id" 1
        # Be explicit about what we are waiting for.
        catch "wait -i $sub_proc_id" wres
        verbose "wres: $wres" 2
        verify_exit_status $executable $wres
    }
 
    if $run_under_valgrind {
	upvar 2 name name
	parse_valgrind_logfile $name $valgrind_logfile
    }

    # force a close of the executable to be safe.
    catch close

    return ""
}

# (end of code from dejagnu.exp)

# GCC_UNDER_TEST is needed by gcc_target_compile
global GCC_UNDER_TEST
if ![info exists GCC_UNDER_TEST] {
    set GCC_UNDER_TEST "[find_gcc]"
}

g++_init

# Initialize dg.
dg-init

# Gather a list of all tests.

# C tests within the testsuite: gcc/testsuite/libdiagnostics.dg/test-*.c
set tests [find $srcdir/$subdir test-*.c]

set tests [lsort $tests]

verbose "tests: $tests"

# libgloss has found the driver (as "xgcc" or "gcc) and stored
# its full path as GCC_UNDER_TEST.
proc get_path_of_driver {} {
    global GCC_UNDER_TEST

    verbose "GCC_UNDER_TEST: $GCC_UNDER_TEST"
    set binary [lindex $GCC_UNDER_TEST 0]
    verbose "binary: $binary"

    return [file dirname $binary]
}

# Expand "SRCDIR" within ARG to the location of the top-level
# src directory

proc diagnostics-expand-vars {arg} {
    verbose "diagnostics-expand-vars: $arg"
    global srcdir
    verbose " srcdir: $srcdir"
    # "srcdir" is that of the gcc/testsuite directory, so
    # we need to go up two levels.
    set arg [string map [list "SRCDIR" $srcdir/../..] $arg]
    verbose " new arg: $arg"
    return $arg
}

# Parameters used when invoking the executables built from the test cases.

global diagnostics-exe-params
set diagnostics-exe-params {}

# Set "diagnostics-exe-params", expanding "SRCDIR" in each arg to the location of
# the top-level srcdir.

proc dg-diagnostics-set-exe-params { args } {
    verbose "dg-diagnostics-set-exe-params: $args"

    global diagnostics-exe-params
    set diagnostics-exe-params {}
    # Skip initial arg (line number)
    foreach arg [lrange $args 1 [llength $args] ] {
	lappend diagnostics-exe-params [diagnostics-expand-vars $arg]
    }
}

proc diagnostics-dg-test { prog do_what extra_tool_flags } {
    verbose "within diagnostics-dg-test..."
    verbose "  prog: $prog"
    verbose "  do_what: $do_what"
    verbose "  extra_tool_flags: $extra_tool_flags"

    global dg-do-what-default
    set dg-do-what [list ${dg-do-what-default} "" P]

    set tmp [dg-get-options $prog]
    foreach op $tmp {
	verbose "Processing option: $op" 3
	set status [catch "$op" errmsg]
	if { $status != 0 } {
	    if { 0 && [info exists errorInfo] } {
		# This also prints a backtrace which will just confuse
		# testcase writers, so it's disabled.
		perror "$name: $errorInfo\n"
	    } else {
		perror "$name: $errmsg for \"$op\"\n"
	    }
	    perror "$name: $errmsg for \"$op\"" 0
	    return
	}
    }

    # If we're not supposed to try this test on this target, we're done.
    if { [lindex ${dg-do-what} 1] == "N" } {
	unsupported "$name"
	verbose "$name not supported on this target, skipping it" 3
	return
    }

    # Determine what to name the built executable.
    #
    # We simply append .exe to the filename, e.g.
    #  "test-foo.c.exe"
    # since some testcases exist in both
    #  "test-foo.c" and
    #  "test-foo.cc"
    # variants, and we don't want them to clobber each other's
    # executables.
    #
    # This also ensures that the source name makes it into the
    # pass/fail output, so that we can distinguish e.g. which test-foo
    # is failing.
    set output_file "[file tail $prog].exe"
    verbose "output_file: $output_file"

    # Create the test executable:
    set extension [file extension $prog]
    if {$extension == ".cc"} {
	set compilation_function "g++_target_compile"
	set options "{additional_flags=$extra_tool_flags}"
    } else {
	set compilation_function "gcc_target_compile"
	# Until recently, <dejagnu.h> assumed -fgnu89-inline
	# Ideally we should fixincludes it (PR other/63613), but
	# for now add -fgnu89-inline when compiling C JIT testcases.
	# See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63613
	# and http://lists.gnu.org/archive/html/dejagnu/2014-10/msg00011.html
	set options "{additional_flags=$extra_tool_flags -fgnu89-inline}"
    }
    verbose "compilation_function=$compilation_function"
    verbose "options=$options"

    set comp_output [$compilation_function $prog $output_file \
			 "executable" $options]
    upvar 1 name name
    if ![diagnostics_check_compile "$name" "initial compilation" \
	    $output_file $comp_output] then {
      return
    }

    # Run the test executable, capturing the PASS/FAIL textual output
    # from the C API, converting it into the Tcl API.

    # We need to set LD_LIBRARY_PATH so that the test files can find
    # libdiagnostics.so
    # Do this using set_ld_library_path_env_vars from target-libpath.exp
    # We will restore the old value later using
    # restore_ld_library_path_env_vars.

    # Unfortunately this API only supports a single saved value, rather
    # than a stack, and g++_init has already called into this API,
    # injecting the appropriate value for LD_LIBRARY_PATH for finding
    # the built copy of libstdc++.
    # Hence the call to restore_ld_library_path_env_vars would restore
    # the *initial* value of LD_LIBRARY_PATH, and attempts to run
    # a C++ testcase after running any prior testcases would thus look
    # in the wrong place for libstdc++.  This led to failures at startup
    # of the form:
    #   ./tut01-hello-world.cc.exe: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by ./tut01-hello-world.cc.exe)
    # when the built libstdc++ is more recent that the system libstdc++.
    #
    # As a workaround, reset the variable "orig_environment_saved" within
    # target-libpath.exp, so that the {set|restore}_ld_library_path_env_vars
    # API saves/restores the current value of LD_LIBRARY_PATH (as set up
    # by g++_init).
    global orig_environment_saved
    set orig_environment_saved 0

    global ld_library_path
    global base_dir
    set ld_library_path "$base_dir/../../"
    set_ld_library_path_env_vars

    # dejagnu.exp's host_execute has code to scrape out test results
    # from the DejaGnu C API and bring back into the tcl world, so we
    # use that to invoke the built code.
    # However, it appears to be buggy; see:
    #  http://lists.gnu.org/archive/html/dejagnu/2014-10/msg00000.html
    # We instead call a patched local copy, "fixed_host_execute", defined
    # above.

    global diagnostics-exe-params
    set args ${diagnostics-exe-params}
    set diagnostics-exe-params {}

    set result [fixed_host_execute $output_file $args ]
    verbose "result: $result"

    restore_ld_library_path_env_vars

    # Normally we would return $comp_output and $output_file to the
    # caller, which would delete $output_file, the generated executable.
    # If we need to debug, it's handy to be able to suppress this behavior,
    # keeping the executable around.
    
    global env
    set preserve_executables [info exists env(PRESERVE_EXECUTABLES)]
    if $preserve_executables {
	set output_file ""
    }
    
    return [list $comp_output $output_file]
}

set DEFAULT_CFLAGS "-I$srcdir/.. -ldiagnostics -g -Wall -Werror"

# Main loop.  This will invoke jig-dg-test on each test-*.c file.
dg-runtest $tests "" $DEFAULT_CFLAGS

# All done.
dg-finish
