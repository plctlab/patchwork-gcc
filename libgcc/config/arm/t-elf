ifeq (,$(findstring __symbian__,$(shell $(gcc_compile_bare) -dM -E - </dev/null)))

ARM_ISA:=$(findstring __ARM_ARCH_ISA_ARM,$(shell $(gcc_compile_bare) -dM -E - </dev/null))
THUMB1_ISA:=$(findstring __ARM_ARCH_ISA_THUMB 1,$(shell $(gcc_compile_bare) -dM -E - </dev/null))

# The condition here must match the one in gcc/config/arm/elf.h and
# libgcc/config/arm/lib1funcs.S.  _arm_muldf3 and _arm_mulsf3 must be included
# first so that the weak multiplication symbols in the corresponding files are
# chosen over the global symbols that _arm_muldivdf3 and _arm_muldivsf3
# inclusion create when only multiplication is used, thus avoiding pulling in
# useless division code.
ifneq (__ARM_ARCH_ISA_THUMB 1,$(ARM_ISA)$(THUMB1_ISA))
LIB1ASMFUNCS += _arm_muldf3
endif
endif # !__symbian__

# This pulls in the available assembly function implementations.
# The soft-fp code is only built for ARMv6M, since there is no
# assembly implementation here for double-precision values.


# Group 0: WEAK overridable function objects.
# See respective sources for rationale.
LIB1ASMFUNCS += \
        _clzsi2 \
	_ctzsi2 \
	_paritysi2 \
	_popcountsi2 \
	_arm_mulsf3 \

ifeq (__ARM_ARCH_ISA_THUMB 1,$(ARM_ISA)$(THUMB1_ISA))
# Group 0B: WEAK overridable function objects built for v6m only.
LIB1ASMFUNCS += \
	_internal_cmpsf2 \
	_muldi3 \
        _arm_addsf3 \
	
endif


# Group 1: Integer function objects.
LIB1ASMFUNCS += \
	_ashldi3 \
	_ashrdi3 \
	_lshrdi3 \
	_clrsbsi2 \
	_clrsbdi2 \
	_clzdi2 \
	_ctzdi2 \
	_ffssi2 \
	_ffsdi2 \
	_paritydi2 \
	_popcountdi2 \
	_cmpdi2 \
	_ucmpdi2 \
	_dvmd_tls \
	_divsi3 \
	_modsi3 \
	_udivsi3 \
	_umodsi3 \


ifeq (__ARM_ARCH_ISA_THUMB 1,$(ARM_ISA)$(THUMB1_ISA))
# Group 1B: Integer function objects built for v6m only.
LIB1ASMFUNCS += \
	_divdi3 \
	_udivdi3 \
	_mulsidi3 \
	_umulsidi3 \
	
endif


# Group 2: Single precision floating point function objects.
LIB1ASMFUNCS += \
	_arm_addsubsf3 \
	_arm_cmpsf2 \
	_arm_fixsfsi \
	_arm_fixunssfsi \
	_arm_floatdisf \
	_arm_floatundisf \
	_arm_muldivsf3 \
	_arm_negsf2 \
	_arm_unordsf2 \

ifeq (__ARM_ARCH_ISA_THUMB 1,$(ARM_ISA)$(THUMB1_ISA))
# Group 2B: Single precision function objects built for v6m only.
LIB1ASMFUNCS += \
        _arm_cfcmpeq \
        _arm_cfcmple \
        _arm_cfrcmple \
        _arm_fcmpeq \
        _arm_fcmpge \
        _arm_fcmpgt \
        _arm_fcmple \
        _arm_fcmplt \
        _arm_fcmpne \
        _arm_eqsf2 \
        _arm_gesf2 \
        _arm_frsubsf3 \
	_fp_exceptionf \
	_fp_checknanf \
	_fp_assemblef \
	_fp_normalizef \

endif


# Group 3: Double precision floating point function objects.
LIB1ASMFUNCS += \
	_arm_addsubdf3 \
	_arm_cmpdf2 \
	_arm_fixdfsi \
	_arm_fixunsdfsi \
	_arm_floatdidf \
	_arm_floatundidf \
	_arm_muldivdf3 \
	_arm_negdf2 \
	_arm_truncdfsf2 \
	_arm_unorddf2 \


# Group 4: Miscellaneous function objects.
LIB1ASMFUNCS += \
	_bb_init_func \
	_call_via_rX \
	_interwork_call_via_rX \


# Currently there is a bug somewhere in GCC's alias analysis
# or scheduling code that is breaking _fpmul_parts in fp-bit.c.
# Disabling function inlining is a workaround for this problem.
HOST_LIBGCC2_CFLAGS += -fno-inline
